
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MiniChat - Pedagogical Example</title>
    <style>
        /* Minimal styling - just enough to be usable */
        body { font-family: sans-serif; padding: 20px; max-width: 1100px; margin: 0 auto; }
        section { border: 1px solid #ccc; padding: 15px; margin: 10px 0; }
        section h3 { margin-top: 0; color: #333; }
        button { padding: 8px 16px; margin: 4px; cursor: pointer; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        input, select { padding: 8px; margin: 4px; width: 180px; }
        video { background: #000; max-width: 300px; height: 200px; }
        .video-grid { display: flex; flex-wrap: wrap; gap: 10px; }
        .video-tile { position: relative; }
        .video-tile label { position: absolute; bottom: 5px; left: 5px; background: rgba(0,0,0,0.7); color: white; padding: 2px 6px; font-size: 12px; }
        .video-tile .media-state { position: absolute; top: 5px; right: 5px; background: rgba(0,0,0,0.7); color: white; padding: 2px 6px; font-size: 10px; }
        .on { color: #4f4; }
        .muted { color: #ff4; }
        .off { color: #f44; }
        #log { background: #f5f5f5; padding: 10px; height: 150px; overflow-y: auto; font-family: monospace; font-size: 12px; }
        .hidden { display: none; }
        
        /* 3-block entry layout */
        .entry-row { display: flex; gap: 15px; flex-wrap: wrap; }
        .entry-block { flex: 1; min-width: 280px; border: 1px solid #ccc; padding: 15px; }
        .entry-block h3 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 8px; }
        .entry-block input { display: block; margin: 6px 0; }
        .entry-block button { margin-top: 10px; }
        .entry-block .status { font-size: 12px; margin-top: 8px; min-height: 20px; }
        .room-code { font-family: monospace; font-size: 18px; font-weight: bold; color: #2563eb; }
    </style>
</head>
<body>
    <h1>üé• MiniChat Example</h1>
    <p><em>A minimal example showing how little JS is needed with MiniChatCore</em></p>

    <!-- ============ SECTION 1: THREE ENTRY OPTIONS ============ -->
    <div id="entrySection" class="entry-row">
        
        <!-- Block 1: Login with existing account -->
        <div class="entry-block">
            <h3>üîê Login</h3>
            <p>Use existing account:</p>
            <input type="email" id="loginEmail" placeholder="Email">
            <input type="password" id="loginPassword" placeholder="Password">
            <button onclick="loginExisting()">Login</button>
            <div class="status" id="loginStatus"></div>
        </div>
        
        <!-- Block 2: Create a new room -->
        <div class="entry-block">
            <h3>üè† Create Room</h3>
            <p>Start a new room as guest:</p>
            <input type="text" id="createUsername" placeholder="Your Name">
            <input type="text" id="createRoomTitle" placeholder="Room Title">
            <button onclick="createRoom()">Create Room</button>
            <div class="status" id="createStatus"></div>
        </div>
        
        <!-- Block 3: Join existing room by code -->
        <div class="entry-block">
            <h3>üö™ Join Room</h3>
            <p>Join an existing room by code:</p>
            <input type="text" id="joinUsername" placeholder="Your Name">
            <input type="text" id="joinRoomCode" placeholder="Room Code">
            <button onclick="joinRoom()">Join Room</button>
            <div class="status" id="joinStatus"></div>
        </div>
    </div>

    <!-- ============ SECTION 2: CHANNEL & USER SELECT (for logged-in users) ============ -->
    <div id="selectionRow" class="hidden" style="display: none; gap: 20px; align-items: flex-start; flex-wrap: wrap;">
        <section id="channelSection">
            <h3>2. Select Channel</h3>
            <select id="channelSelect"><option value="">-- Select Channel --</option></select>
            <button onclick="selectChannel()">Select</button>
            <button onclick="logout()">Logout</button>
        </section>

        <section id="userSection">
            <h3>2b. Or Select User (Quick Chat)</h3>
            <select id="userSelect"><option value="">-- Select User --</option></select>
            <button onclick="selectUser()">Chat</button>
        </section>
    </div>

    <!-- ============ SECTION 3: MEDIA CONTROLS ============ -->
    <section id="mediaSection" class="hidden">
        <h3>3. Local Media</h3>
        <div class="video-grid">
            <div class="video-tile">
                <video id="localVideo" autoplay muted playsinline></video>
                <label>You</label>
            </div>
        </div>
        <div style="margin-top: 10px;">
            <button onclick="chat.toggleAudio()">Toggle Audio</button>
            <button onclick="chat.toggleVideo()">Toggle Video</button>
            <button onclick="chat.toggleScreencast()">Toggle Screen</button>
            <button onclick="chat.toggleMuteAudio()">Mute/Unmute Mic</button>
            <button onclick="chat.toggleMuteVideo()">Hide/Show Video</button>
        </div>
        <p>Audio: <span id="audioState">OFF</span> | Video: <span id="videoState">OFF</span> | Screen: <span id="screenState">OFF</span></p>
    </section>

    <!-- ============ SECTION 4: JOIN CHANNEL ============ -->
    <section id="joinSection" class="hidden">
        <h3>4. Join Channel <span id="channelStatus"></span></h3>
        <button onclick="chat.join()" id="joinBtn">Join Channel</button>
        <button onclick="chat.returnToLobby()" id="leaveBtn" disabled>Return to Lobby</button>
        <button onclick="exitChannelFully()" id="exitBtn" disabled>Exit Channel</button>
        <div id="roomCodeDisplay" style="margin-top: 10px; display: none;">
            Share this code: <span class="room-code" id="currentRoomCode"></span>
        </div>
    </section>

    <!-- ============ SECTION 5: REMOTE MEMBERS ============ -->
    <section id="membersSection" class="hidden">
        <h3>5. Remote Members</h3>
        <button onclick="showMembers()">Get Members</button>
        <div id="remoteVideos" class="video-grid"></div>
    </section>

    <!-- ============ LOG OUTPUT ============ -->
    <section>
        <h3>Event Log</h3>
        <div id="log"></div>
    </section>

    <!-- ============ THE JAVASCRIPT - Notice how minimal it is! ============ -->

   
    <script type="importmap">
    {
        "imports": {
            "minichat-core": "https://proto2.makedo.com:8883/v02/scripts/minichat-core.js",
            "config": "https://proto2.makedo.com:8883/v02/scripts/configServer.js"
        }
    }
    </script> 
<!--
    <script type="importmap">
    {
        "imports": {
            "minichat-core": "./scripts/minichat-core.js",
            "config": "./scripts/configLocal.js"
        }
    }
    </script>
-->

    <script type="module">
        import MiniChatCore from 'minichat-core';

        // Context credentials for anonymous signups (get yours from makedo.com/developers)
        const CONTEXT_CONFIG = {
            contextId: 'Kw6w6w6w6w', // server/local test context
            contextAuthToken: 'Kw6w6w6w6w'
            //contextId: 'Ktest02', // server/local test context
            //contextAuthToken: 'Ktest02'
        };

        // Create the chat instance (globally accessible for onclick handlers)
        window.chat = new MiniChatCore(CONTEXT_CONFIG);

        // Track remote video tiles
        const remoteTiles = new Map();

        // ============ SETUP EVENT HANDLERS ============
        
        // Give the core our local video element - it manages srcObject automatically
        chat.setLocalVideoElement(document.getElementById('localVideo'));

        // Login events (for regular login flow)
        chat.onLogin = (user) => {
            log(`‚úì Logged in as ${user.email || user.username || 'anonymous'}`);
        };

        // Channels loaded - populate dropdown
        chat.onChannelsLoaded = (channels) => {
            const select = document.getElementById('channelSelect');
            select.innerHTML = '<option value="">-- Select Channel --</option>';
            channels.forEach(ch => {
                select.innerHTML += `<option value="${ch.id}">${ch.title || 'Untitled'}</option>`;
            });
            log(`Loaded ${channels.length} channels`);
        };

        // Users loaded - populate dropdown
        chat.onUsersLoaded = (users) => {
            const select = document.getElementById('userSelect');
            select.innerHTML = '<option value="">-- Select User --</option>';
            users.forEach(u => {
                select.innerHTML += `<option value="${u.pid}">${u.username || 'Unknown'}</option>`;
            });
            log(`Loaded ${users.length} users`);
        };

        // Channel selected - show media controls and create member tiles
        chat.onChannelSelected = async (channel) => {
            log(`Selected: ${channel.title}`);
            show('mediaSection');
            show('joinSection');
            show('membersSection');
            
            // Clear any existing tiles
            clearRemoteTiles();
            
            // ALWAYS fetch fresh channel data - cached data from loadChannels() might be stale
            log('Fetching fresh channel data with updated member statuses...');
            let freshChannel;
            try {
                freshChannel = await chat.getChannelById(channel.id);
                log(`Fresh data fetched - ${freshChannel.members?.length || 0} members`);
            } catch (error) {
                log(`‚ö†Ô∏è Could not fetch fresh channel data, using cached: ${error.message}`);
                freshChannel = channel; // Fallback to cached
            }
            
            // Get all members (including self) from fresh channel data
            let members = freshChannel.members || [];
            
            if (members.length === 0) {
                // If channel.members is empty, fetch via getMembers API
                log('No members in channel data, fetching via getMembers...');
                members = await chat.getCurrentChannelMembers();
            }
            
            // Create tiles for ALL members (including self) using actual status from member data
            members.forEach(member => {
                const isLocal = member.id === chat.currentMemberId;
                const displayName = isLocal ? 'You' : (member.local_name || member.user?.username || 'Unknown');
                const displayStatus = chat.getDisplayStatus(member.status);
                
                createMemberPlaceholder(member.id, displayName, displayStatus, isLocal);
                
                if (isLocal) {
                    log(`Your status: ${member.status} (${displayStatus})`);
                }
            });
            
            log(`Created ${members.length} member placeholders with current statuses`);
            
            // Show LOBBY status when entering channel
            document.getElementById('channelStatus').textContent = 'üë• LOBBY';
        };

        // Joined channel
        chat.onJoined = () => {
            log('‚úì Joined channel - you are LIVE');
            document.getElementById('joinBtn').disabled = true;
            document.getElementById('leaveBtn').disabled = false;
            document.getElementById('exitBtn').disabled = false;
            document.getElementById('channelStatus').textContent = 'üî¥ LIVE';
            
            // Show room code for sharing
            const roomCode = chat.currentRoomCode;
            if (roomCode) {
                document.getElementById('currentRoomCode').textContent = roomCode;
                document.getElementById('roomCodeDisplay').style.display = 'block';
            }
        };

        // Left channel - keep member grid visible for quick rejoin
        chat.onLeft = () => {
            log('Returned to lobby - member grid still visible');
            document.getElementById('joinBtn').disabled = false;
            document.getElementById('leaveBtn').disabled = true;
            document.getElementById('exitBtn').disabled = false;  // Can still exit fully
            document.getElementById('channelStatus').textContent = 'üë• LOBBY';
            document.getElementById('roomCodeDisplay').style.display = 'none';
            
            // DON'T clear member tiles - keep them visible for quick rejoin
            // Just hide video streams (will happen automatically via onMemberStreamEnd)
        };

        // Local media changed - update UI
        chat.onLocalMediaChange = () => {
            const state = chat.localMediaState;
            const screen = chat.screencastState;
            document.getElementById('audioState').textContent = state.audio ? (state.audioMuted ? 'MUTED' : 'ON') : 'OFF';
            document.getElementById('videoState').textContent = state.video ? (state.videoMuted ? 'HIDDEN' : 'ON') : 'OFF';
            document.getElementById('screenState').textContent = screen.video ? (screen.videoMuted ? 'HIDDEN' : 'ON') : 'OFF';
        };

        // New member joined - create placeholder tile immediately
        chat.onMemberJoined = (memberId) => {
            const member = chat.getMember(memberId);
            log(`Member joined: ${member?.username || memberId}`);
            
            // Create placeholder tile for the new member
            const displayName = member?.local_name || member?.user_username || member?.username || 'Unknown';
            const displayStatus = member?.member_status ? chat.getDisplayStatus(member.member_status) : 'INACTIVE';
            
            createMemberPlaceholder(memberId, displayName, displayStatus, false);
        };

        // Member update (status changes, profile updates, etc.)
        chat.onMemberUpdate = (memberId) => {
            const member = chat.getMember(memberId);
            if (!member) return;
            
            const isSelf = memberId === chat.currentMemberId;
            log(`Member update: ${member.username || memberId}${isSelf ? ' (you)' : ''}`);
            
            const tileId = `tile-${memberId}-camera`;
            const tile = document.getElementById(tileId);
            
            if (!tile) {
                // Member doesn't have a tile yet - create one
                const displayName = member.local_name || member.user_username || member.username || 'Unknown';
                const displayStatus = member.member_status ? chat.getDisplayStatus(member.member_status) : 'INACTIVE';
                log(`Creating tile for updated member: ${displayName} (${displayStatus})`);
                createMemberPlaceholder(memberId, displayName, displayStatus, isSelf);
            } else {
                // Update existing tile's status badge
                const statusBadge = tile.querySelector('.status-badge');
                if (statusBadge && member.member_status) {
                    const displayStatus = chat.getDisplayStatus(member.member_status);
                    statusBadge.textContent = displayStatus;
                    log(`Updated status badge for ${member.username}: ${displayStatus}`);
                }
            }
        };

        // Member left LIVE state (stopped WebRTC streaming)
        // NOTE: This does NOT mean they left the channel - they may have returned to LOBBY
        // Check their status to decide whether to remove the tile
        chat.onMemberLeft = (memberId) => {
            const member = chat.getMember(memberId);
            log(`Member left LIVE: ${member?.username || memberId}`);
            
            // Check if member is still in channel (in lobby) or fully exited
            const status = chat.getDisplayStatus(member?.member_status);
            
            if (status === 'LOBBY') {
                // Member returned to lobby - keep tile visible with LOBBY badge
                // Video is already hidden by MiniChatCore
                log(`${member.username} is now in lobby - keeping tile`);
            } else {
                // Member fully exited (INACTIVE status) - remove tile
                log(`${member.username} fully exited, removing tile`);
                removeRemoteTile(memberId);
            }
        };

        // Member started streaming - show video in existing tile
        chat.onMemberStreamStart = (memberId, streamType) => {
            const member = chat.getMember(memberId);
            log(`Stream started: ${member?.username} (${streamType})`);
            
            const tileId = `tile-${memberId}-${streamType}`;
            let tile = document.getElementById(tileId);
            
            // If tile doesn't exist (late-joining member), create it first
            if (!tile) {
                const displayStatus = member?.member_status ? chat.getDisplayStatus(member.member_status) : 'INACTIVE';
                createMemberPlaceholder(memberId, member?.username, displayStatus, false);
                tile = document.getElementById(tileId);
            }
            
            if (tile) {
                const placeholder = tile.querySelector('.placeholder-content');
                const video = tile.querySelector('video');
                const label = tile.querySelector('label');
                const stateEl = tile.querySelector('.media-state');
                
                // Show video elements, hide placeholder
                if (placeholder) placeholder.style.display = 'none';
                if (video) video.style.display = 'block';
                if (label) label.style.display = 'block';
                if (stateEl) stateEl.style.display = 'block';
                
                // Register video element with core - auto-attaches stream
                if (video) {
                    chat.setMemberVideoElement(memberId, streamType, video);
                }
                
                // Update media state
                updateRemoteTileState(memberId, streamType);
            }
        };

        // Member stopped streaming - hide video, show placeholder
        chat.onMemberStreamEnd = (memberId, streamType) => {
            log(`Stream ended: ${memberId} (${streamType})`);
            
            const tileId = `tile-${memberId}-${streamType}`;
            const tile = document.getElementById(tileId);
            
            if (tile) {
                const placeholder = tile.querySelector('.placeholder-content');
                const video = tile.querySelector('video');
                const label = tile.querySelector('label');
                const stateEl = tile.querySelector('.media-state');
                
                // Hide video elements, show placeholder
                if (video) video.style.display = 'none';
                if (label) label.style.display = 'none';
                if (stateEl) stateEl.style.display = 'none';
                if (placeholder) placeholder.style.display = 'flex';
            }
        };

        // Member media state changed (mute/unmute)
        chat.onMemberMediaChange = (memberId, streamType) => {
            updateRemoteTileState(memberId, streamType);
        };

        // Errors
        chat.onError = (context, error) => {
            log(`‚ùå Error in ${context}: ${error.message}`);
        };

        // ============ SIMPLE FUNCTIONS FOR BUTTONS ============

        // Block 1: Login with existing account
        window.loginExisting = async function() {
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            const status = document.getElementById('loginStatus');
            
            if (!email || !password) {
                status.textContent = '‚ùå Email and password required';
                return;
            }
            
            status.textContent = 'Logging in...';
            try {
                await chat.login(email, password);
                await chat.loadChannels();
                await chat.loadUsers();
                hideEntrySection();
                showSelectionRow();
            } catch (e) {
                status.textContent = '‚ùå ' + e.message;
            }
        };
        
        // Block 2: Create a new room (anonymous)
        window.createRoom = async function() {
            const username = document.getElementById('createUsername').value;
            const roomTitle = document.getElementById('createRoomTitle').value;
            const status = document.getElementById('createStatus');
            
            if (!username) {
                status.textContent = '‚ùå Please enter your name';
                return;
            }
            
            status.textContent = 'Creating room...';
            try {
                // Sign up as anonymous user
                await chat.signupAnonymous(username);
                log(`‚úì Signed up as anonymous: ${username}`);
                
                // Create a new channel
                const channel = await chat.createChannel({ 
                    title: roomTitle || `${username}'s Room`,
                    allowsGuests: true 
                });
                log(`‚úì Created room: ${channel.title}`);
                
                // Show room code
                status.innerHTML = `Room code: <span class="room-code">${channel.room_code}</span>`;
                
                // Join the channel
                await chat.joinByRoomCode(channel.room_code);
                log(`‚úì Joined room with code: ${channel.room_code}`);
                
                // Go directly to media section (skip channel select)
                hideEntrySection();
                show('mediaSection');
                show('joinSection');
                show('membersSection');
                
            } catch (e) {
                status.textContent = '‚ùå ' + e.message;
                log(`‚ùå Create room error: ${e.message}`);
            }
        };
        
        // Block 3: Join existing room by code (anonymous)
        window.joinRoom = async function() {
            const username = document.getElementById('joinUsername').value;
            const roomCode = document.getElementById('joinRoomCode').value.trim();
            const status = document.getElementById('joinStatus');
            
            if (!username) {
                status.textContent = '‚ùå Please enter your name';
                return;
            }
            if (!roomCode) {
                status.textContent = '‚ùå Please enter room code';
                return;
            }
            
            status.textContent = 'Joining room...';
            try {
                // Sign up as anonymous user
                await chat.signupAnonymous(username);
                log(`‚úì Signed up as anonymous: ${username}`);
                
                // Join by room code
                await chat.joinByRoomCode(roomCode);
                log(`‚úì Joined room with code: ${roomCode}`);
                log(`‚úì Room title: ${chat.selectedChannel?.title || 'Unknown'}`);
                
                status.textContent = '‚úì Joined!';
                
                // Go directly to media section (skip channel select)
                hideEntrySection();
                show('mediaSection');
                show('joinSection');
                show('membersSection');
                
            } catch (e) {
                status.textContent = '‚ùå ' + e.message;
                log(`‚ùå Join room error: ${e.message}`);
            }
        };

        window.selectChannel = async function() {
            const channelId = document.getElementById('channelSelect').value;
            if (!channelId) return alert('Please select a channel');
            
            await chat.selectChannel(channelId);
        };

        window.selectUser = async function() {
            const userId = document.getElementById('userSelect').value;
            if (!userId) return alert('Please select a user');
            
            await chat.selectUser(userId);
        };

        window.logout = function() {
            chat.logout();
            showEntrySection();
            hideSelectionRow();
            hide('mediaSection');
            hide('joinSection');
            hide('membersSection');
            clearRemoteTiles();
        };
        
        window.exitChannelFully = function() {
            log('Exiting channel fully - clearing members');
            chat.exitChannel();
            
            // Clear member tiles and hide sections
            clearRemoteTiles();
            hide('mediaSection');
            hide('joinSection');
            hide('membersSection');
            
            // Reset buttons
            document.getElementById('joinBtn').disabled = false;
            document.getElementById('leaveBtn').disabled = true;
            document.getElementById('exitBtn').disabled = true;
        };

        window.showMembers = function() {
            const memberIds = chat.getMemberIds();
            log(`Current members: ${memberIds.length}`);
            memberIds.forEach(id => {
                const m = chat.getMember(id);
                log(`  - ${m.username} (camera: ${m.hasCamera}, screen: ${m.hasScreencast})`);
            });
        };

        // ============ HELPER FUNCTIONS ============

        /**
         * Create a placeholder tile for a member (shown before/without video stream)
         * @param {string} memberId - Member ID
         * @param {string} username - Display name
         * @param {string} status - Display status (ACTIVE, LOBBY, INACTIVE)
         * @param {boolean} isLocal - True if this is the local user
         */
        function createMemberPlaceholder(memberId, username, status, isLocal) {
            const container = document.getElementById('remoteVideos');
            const tileId = `tile-${memberId}-camera`;
            
            // Don't create duplicate
            if (document.getElementById(tileId)) {
                return;
            }
            
            const tile = document.createElement('div');
            tile.className = 'video-tile';
            tile.id = tileId;
            tile.dataset.memberId = memberId;
            tile.style.cssText = 'width: 300px; height: 200px; position: relative;';
            
            // Placeholder content (visible when no video)
            const placeholder = document.createElement('div');
            placeholder.className = 'placeholder-content';
            placeholder.style.cssText = 'position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px;';
            
            // Initials
            const initials = document.createElement('div');
            initials.style.cssText = 'font-size: 48px; font-weight: bold; margin-bottom: 8px;';
            initials.textContent = getInitials(username);
            
            // Name
            const nameEl = document.createElement('div');
            nameEl.style.cssText = 'font-size: 16px; margin-bottom: 4px;';
            nameEl.textContent = isLocal ? 'You' : username;
            
            // Status badge
            const statusBadge = document.createElement('div');
            statusBadge.className = 'status-badge';
            statusBadge.style.cssText = 'font-size: 12px; padding: 4px 8px; background: rgba(255,255,255,0.2); border-radius: 4px;';
            statusBadge.textContent = status;
            statusBadge.dataset.status = status;
            
            placeholder.appendChild(initials);
            placeholder.appendChild(nameEl);
            placeholder.appendChild(statusBadge);
            
            // Video element (hidden initially)
            const video = document.createElement('video');
            video.autoplay = true;
            video.playsInline = true;
            video.muted = isLocal;
            video.style.cssText = 'position: absolute; inset: 0; width: 100%; height: 100%; display: none; background: #000;';
            
            // Label overlay (for video)
            const label = document.createElement('label');
            label.textContent = `${isLocal ? 'You' : username} (camera)`;
            label.style.display = 'none';
            
            // Media state indicator (for video)
            const stateEl = document.createElement('div');
            stateEl.className = 'media-state';
            stateEl.innerHTML = 'üé§ <span class="audio">...</span> üìπ <span class="video">...</span>';
            stateEl.style.display = 'none';
            
            tile.appendChild(placeholder);
            tile.appendChild(video);
            tile.appendChild(label);
            tile.appendChild(stateEl);
            
            container.appendChild(tile);
        }
        
        function getInitials(name) {
            if (!name) return '?';
            const parts = name.trim().split(' ');
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        }

        function createRemoteTile(memberId, streamType, username) {
            const container = document.getElementById('remoteVideos');
            const tileId = `${memberId}-${streamType}`;
            
            // Don't create duplicate
            if (document.getElementById(tileId)) {
                return document.getElementById(tileId).querySelector('video');
            }
            
            const tile = document.createElement('div');
            tile.className = 'video-tile';
            tile.id = tileId;
            
            const video = document.createElement('video');
            video.autoplay = true;
            video.playsInline = true;
            
            const label = document.createElement('label');
            label.textContent = `${username || 'Unknown'} (${streamType})`;
            
            // Media state indicator
            const stateEl = document.createElement('div');
            stateEl.className = 'media-state';
            stateEl.innerHTML = 'üé§ <span class="audio">...</span> üìπ <span class="video">...</span>';
            
            tile.appendChild(video);
            tile.appendChild(label);
            tile.appendChild(stateEl);
            container.appendChild(tile);
            
            remoteTiles.set(tileId, tile);
            
            // Update state immediately
            updateRemoteTileState(memberId, streamType);
            
            return video;
        }

        function updateRemoteTileState(memberId, streamType) {
            const tileId = `tile-${memberId}-${streamType}`;
            const tile = document.getElementById(tileId);
            if (!tile) return;
            
            const states = chat.getMemberMediaStates(memberId);
            if (!states) return;
            
            const audioKey = streamType === 'camera' ? 'cam_audio_detail' : 'screen_audio_detail';
            const videoKey = streamType === 'camera' ? 'cam_video_detail' : 'screen_video_detail';
            
            const audioEl = tile.querySelector('.media-state .audio');
            const videoEl = tile.querySelector('.media-state .video');
            
            if (audioEl) {
                audioEl.textContent = states[audioKey] || 'OFF';
                audioEl.className = 'audio ' + (states[audioKey] === 'ON' ? 'on' : states[audioKey] === 'MUTED' ? 'muted' : 'off');
            }
            if (videoEl) {
                videoEl.textContent = states[videoKey] || 'OFF';
                videoEl.className = 'video ' + (states[videoKey] === 'ON' ? 'on' : states[videoKey] === 'HIDDEN' ? 'muted' : 'off');
            }
        }

        function removeRemoteTile(memberId, streamType = null) {
            if (streamType) {
                const tileId = `${memberId}-${streamType}`;
                const tile = remoteTiles.get(tileId);
                if (tile) {
                    chat.clearMemberVideoElement(memberId, streamType);
                    tile.remove();
                    remoteTiles.delete(tileId);
                }
            } else {
                // Remove all tiles for this member
                ['camera', 'screencast'].forEach(st => removeRemoteTile(memberId, st));
            }
        }

        function clearRemoteTiles() {
            // Clear video element references
            remoteTiles.forEach((tile, key) => {
                const parts = key.split('-');
                if (parts.length >= 3) {
                    const memberId = parts[1];
                    const streamType = parts[2];
                    chat.clearMemberVideoElement(memberId, streamType);
                }
            });
            remoteTiles.clear();
            
            // Clear all tiles from DOM (including placeholder-only tiles not in remoteTiles)
            const container = document.getElementById('remoteVideos');
            if (container) {
                container.innerHTML = '';
            }
        }

        function show(id) { document.getElementById(id).classList.remove('hidden'); }
        function hide(id) { document.getElementById(id).classList.add('hidden'); }
        function showSelectionRow() { document.getElementById('selectionRow').style.display = 'flex'; }
        function hideSelectionRow() { document.getElementById('selectionRow').style.display = 'none'; }
        function hideEntrySection() { document.getElementById('entrySection').classList.add('hidden'); }
        function showEntrySection() { document.getElementById('entrySection').classList.remove('hidden'); }
        function log(msg) {
            const logEl = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            logEl.innerHTML += `[${time}] ${msg}<br>`;
            logEl.scrollTop = logEl.scrollHeight;
        }

        log('Ready. Login, create a room, or join with a code.');
    </script>
</body>
</html>
